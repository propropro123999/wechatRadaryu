<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Word è½¬ HTML å·¥å…· - ICviews</title>
    <link rel="stylesheet" href="gemini-ui.css" />
    <link href="https://fonts.googleapis.com/css2?family=Google+Sans:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- Mammoth.js for DOCX parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    <!-- JSZip for Download -->
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <style>
        /* Auth Overlay Styles */
        .auth-overlay {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.6);
            backdrop-filter: blur(20px);
            z-index: 9999;
        }

        .auth-card {
            width: 400px;
            max-width: 90vw;
            background: var(--gem-color-bg-surface);
            backdrop-filter: var(--gem-blur-lg);
            -webkit-backdrop-filter: var(--gem-blur-lg);
            border-radius: var(--gem-radius-lg);
            padding: 32px;
            box-shadow: var(--gem-shadow-card);
            border: 1px solid rgba(255, 255, 255, 0.4);
        }

        .auth-icon-wrapper {
            width: 56px;
            height: 56px;
            background: linear-gradient(135deg, #007AFF, #5856D6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 20px;
            color: white;
        }

        .auth-icon-wrapper svg {
            width: 32px;
            height: 32px;
        }

        .error-message {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #D32F2F;
            font-size: 13px;
        }

        .animate-scale-in {
            animation: scaleIn 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
        }

        @keyframes scaleIn {
            from {
                opacity: 0;
                transform: scale(0.9);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .drop-zone {
            border: 2px dashed var(--gem-color-border);
            border-radius: 16px;
            padding: 48px;
            text-align: center;
            background: rgba(255, 255, 255, 0.5);
            transition: all 0.3s ease;
            cursor: pointer;
            margin-bottom: 24px;
        }

        .drop-zone:hover,
        .drop-zone.drag-over {
            border-color: var(--gem-color-primary);
            background: rgba(66, 133, 244, 0.05);
            transform: scale(1.01);
        }

        .preview-container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            display: none;
            /* Hidden by default */
        }

        .preview-header {
            padding: 16px 24px;
            border-bottom: 1px solid var(--gem-color-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #F8F9FA;
            flex-wrap: wrap;
            /* Allow wrapping on small screens */
            gap: 12px;
        }

        .preview-content {
            padding: 40px;
            max-width: 800px;
            margin: 0 auto;
            min-height: 400px;
            overflow-y: auto;
            max-height: 800px;
        }

        /* Word Content Styles for Preview */
        .word-content img {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .word-content table {
            border-collapse: collapse;
            width: 100%;
            margin: 1em 0;
        }

        .word-content td,
        .word-content th {
            border: 1px solid #ddd;
            padding: 8px;
        }

        /* Image Controls Overlay */
        .img-wrapper {
            position: relative;
            display: inline-block;
            margin: 10px 0;
            max-width: 100%;
        }

        .img-controls {
            position: absolute;
            top: 8px;
            right: 8px;
            display: none;
            gap: 6px;
            z-index: 10;
        }

        .img-wrapper:hover .img-controls {
            display: flex;
        }

        .img-btn {
            background: rgba(0, 0, 0, 0.6);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 12px;
            cursor: pointer;
            backdrop-filter: blur(4px);
            display: flex;
            align-items: center;
            gap: 4px;
            transition: background 0.2s;
        }

        .img-btn:hover {
            background: rgba(0, 122, 255, 0.9);
        }
    </style>
</head>

<body>

    <!-- Auth Overlay -->
    <div id="auth-overlay" class="auth-overlay" style="display: flex;">
        <div class="auth-card animate-scale-in">
            <div class="auth-icon-wrapper">
                <svg viewBox="0 0 24 24" fill="currentColor">
                    <path
                        d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z" />
                </svg>
            </div>
            <h2 style="margin-bottom: 8px;">Word è½¬ HTML å·¥å…·</h2>
            <p style="color: var(--gem-color-text-secondary); margin-bottom: 24px; font-size: 14px;">è¯·è¾“å…¥æˆæƒç ä»¥ç»§ç»­ä½¿ç”¨</p>
            <div class="input-group" style="margin-bottom: 24px;">
                <input type="text" id="auth-code-input" class="gem-input" placeholder="è¾“å…¥æˆæƒç " autocomplete="off">
            </div>
            <button class="gem-button gem-button-primary" onclick="verifyAuth()" style="width: 100%;">
                éªŒè¯æˆæƒ
            </button>
            <div id="auth-error" class="error-message" style="margin-top: 12px; display: none;">
                <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor">
                    <path
                        d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z" />
                </svg>
                <span>æˆæƒç æ— æ•ˆ</span>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <div class="container animate-fade-in" id="main-content" style="display: none; max-width: 1000px;">

        <!-- Header -->
        <header style="margin-bottom: 32px; display: flex; align-items: center; justify-content: space-between;">
            <div class="flex items-center gap-3">
                <a href="index.html" class="gem-button gem-button-secondary"
                    style="padding: 8px; border-radius: 50%; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center;">
                    <svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor">
                        <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z" />
                    </svg>
                </a>
                <div>
                    <h1 style="font-size: 24px; margin-bottom: 4px;">Word è½¬ HTML</h1>
                    <p style="color: var(--gem-color-text-secondary); font-size: 14px;">.docx æ ¼å¼ Â· æ™ºèƒ½å›¾æ–‡ä¿ç•™ Â· çº¯æœ¬åœ°å¤„ç†</p>
                </div>
            </div>
        </header>

        <!-- Drop Zone -->
        <div class="drop-zone" id="drop-zone">
            <div style="font-size: 48px; margin-bottom: 16px;">ğŸ“„</div>
            <h3 style="margin-bottom: 8px; color: var(--gem-color-text-primary);">æ‹–æ‹½ Word æ–‡æ¡£åˆ°è¿™é‡Œ</h3>
            <p style="color: var(--gem-color-text-secondary); margin-bottom: 24px;">æ”¯æŒ .docx æ ¼å¼ï¼Œæœ€å¤§æ”¯æŒ 50MB</p>
            <button class="gem-button gem-button-primary" onclick="document.getElementById('file-input').click()">
                é€‰æ‹©æ–‡ä»¶
            </button>
            <input type="file" id="file-input" accept=".docx" style="display: none;">
        </div>

        <!-- Preview Section -->
        <div class="preview-container" id="preview-container">
            <div class="preview-header">
                <div class="flex items-center gap-2">
                    <span style="font-weight: 500;" id="file-name-display">Document.docx</span>
                    <span class="gem-chip gem-chip-success">è½¬æ¢æˆåŠŸ</span>
                </div>
                <div class="flex gap-2 items-center">
                    <div class="flex gap-2 items-center">
                        <button id="btn-cloud-upload" class="gem-button gem-button-primary" onclick="uploadAllToCloud()"
                            style="background: linear-gradient(135deg, #10B981, #059669); border:none;">
                            <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor"
                                style="margin-right: 4px;">
                                <path
                                    d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM14 13v4h-4v-4H7l5-5 5 5h-3z" />
                            </svg>
                            ä¸€é”®è½¬ä¸ºäº‘ç«¯å›¾
                        </button>

                        <button id="btn-cloud-delete" class="gem-button gem-button-secondary"
                            onclick="deleteAllCloudImages()"
                            style="display: none; color: #D32F2F; border-color: rgba(211, 47, 47, 0.3);">
                            <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor"
                                style="margin-right: 4px;">
                                <path
                                    d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z" />
                            </svg>
                            åˆ é™¤äº‘ç«¯å›¾ç‰‡
                        </button>

                        <button class="gem-button gem-button-secondary" onclick="copyHTML()">
                            <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor"
                                style="margin-right: 4px;">
                                <path
                                    d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z" />
                            </svg>
                            HTML
                        </button>

                        <button class="gem-button gem-button-primary" onclick="copyRichText()">
                            <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor"
                                style="margin-right: 4px;">
                                <path
                                    d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z" />
                            </svg>
                            å¤åˆ¶å…¨æ–‡
                        </button>
                    </div>
                </div>
                <div class="preview-content word-content" id="preview-content">
                    <!-- Converted content will appear here -->
                </div>
            </div>

            <!-- Hidden container for clipboard operations -->
            <div id="clipboard-helper" contenteditable="true" style="position: absolute; left: -9999px;"></div>

        </div>

        <script>
            // --- Auth Configuration ---
            const TOOL_KEY = 'word-parser';
            let AUTH_CODES = {}; // Will load from json

            // --- Initialization ---
            document.addEventListener('DOMContentLoaded', async () => {
                await loadAuthCodes();
                checkAuth();

                // Setup Drop Zone
                const dropZone = document.getElementById('drop-zone');
                const fileInput = document.getElementById('file-input');

                // Prevent default drag behaviors
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                    dropZone.addEventListener(eventName, preventDefaults, false);
                    document.body.addEventListener(eventName, preventDefaults, false);
                });

                // Highlight drop zone when item is dragged over it
                ['dragenter', 'dragover'].forEach(eventName => {
                    dropZone.addEventListener(eventName, highlight, false);
                });

                ['dragleave', 'drop'].forEach(eventName => {
                    dropZone.addEventListener(eventName, unhighlight, false);
                });

                // Handle dropped files
                dropZone.addEventListener('drop', handleDrop, false);
                fileInput.addEventListener('change', (e) => handleFiles(e.target.files), false);
            });

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            function highlight(e) {
                document.getElementById('drop-zone').classList.add('drag-over');
            }

            function unhighlight(e) {
                document.getElementById('drop-zone').classList.remove('drag-over');
            }

            function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                handleFiles(files);
            }

            function handleFiles(files) {
                if (files.length === 0) return;
                const file = files[0];

                if (!file.name.endsWith('.docx')) {
                    alert('ä»…æ”¯æŒ .docx æ ¼å¼çš„ Word æ–‡æ¡£');
                    return;
                }

                // Update UI
                document.getElementById('file-name-display').innerText = file.name;
                document.getElementById('preview-content').innerHTML = '<div style="text-align:center; padding: 40px; color: #666;">æ­£åœ¨è½¬æ¢ä¸­...</div>';
                document.getElementById('preview-container').style.display = 'block';

                // Proce ss File
                const reader = new FileReader();
                reader.onload = function (loadEvent) {
                    const arrayBuffer = loadEvent.target.result;
                    convertDocxToHtml(arrayBuffer);
                };
                reader.readAsArrayBuffer(file);
            }

            function convertDocxToHtml(arrayBuffer) {
                mammoth.convertToHtml({ arrayBuffer: arrayBuffer })
                    .then(displayResult)
                    .catch(handleError);
            }

            async function displayResult(result) {
                const rawHtml = result.value;
                const messages = result.messages;

                // Post-process HTML: Resize images and add wrappers
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = rawHtml;

                const imgs = tempDiv.querySelectorAll('img');
                const processedImages = [];

                for (let img of imgs) {
                    let src = img.getAttribute('src');
                    if (src) {
                        // 1. Handle External/Malformed URLs
                        if (!src.startsWith('data:image')) {
                            try {
                                // Clean URL (remove trailing quotes, spaces, etc. common in bad parsing)
                                let cleanSrc = src.replace(/%22/g, '').replace(/"/g, '').split(' ')[0].trim();

                                // Log for debugging
                                if (src !== cleanSrc) console.log('Cleaned URL:', src, '->', cleanSrc);

                                // Fetch and convert to Base64 via Proxy
                                const newBase64 = await fetchExternalImage(cleanSrc);
                                if (newBase64) {
                                    img.setAttribute('src', newBase64);
                                    src = newBase64; // Update local var for resizing
                                }
                            } catch (e) {
                                console.warn('Failed to fetch external image:', src, e);
                            }
                        }

                        // 2. Resize if it is now a Base64 image
                        if (src && src.startsWith('data:image')) {
                            try {
                                const newSrc = await resizeImage(src, 800);
                                img.setAttribute('src', newSrc);
                            } catch (e) {
                                console.warn('Image resize failed', e);
                            }
                        }
                    }

                    // Wrap in div for controls
                    // We'll replace the img element with the wrapper in the DOM
                    const wrapper = document.createElement('div');
                    wrapper.className = 'img-wrapper';

                    // Clone img to keep attributes, but we need to insert wrapper
                    // Replace img with wrapper, then append img to wrapper
                    img.parentNode.insertBefore(wrapper, img);
                    wrapper.appendChild(img);

                    // Add Controls
                    const controls = document.createElement('div');
                    controls.className = 'img-controls';
                    controls.innerHTML = `
                    <button class="img-btn" onclick="copySingleImage(this)" title="å¤åˆ¶å›¾ç‰‡">
                        <svg viewBox="0 0 24 24" width="12" height="12" fill="currentColor"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg>
                        å¤åˆ¶
                    </button>
                    <button class="img-btn" onclick="downloadSingleImage(this)" title="ä¸‹è½½å›¾ç‰‡">
                        <svg viewBox="0 0 24 24" width="12" height="12" fill="currentColor"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
                        ä¸‹è½½
                    </button>
                `;
                    wrapper.appendChild(controls);
                }

                document.getElementById('preview-content').innerHTML = tempDiv.innerHTML;

                if (messages.length > 0) {
                    console.log('Conversion messages:', messages);
                }
            }

            // --- External Image Helper ---
            async function fetchExternalImage(url) {
                try {
                    // Try Direct Fetch first (if CORS allows)
                    // If it fails, use Proxy
                    let blob;
                    try {
                        const resp = await fetch(url);
                        if (!resp.ok) throw new Error('Direct fetch failed');
                        blob = await resp.blob();
                    } catch (e) {
                        console.log('Direct fetch failed, trying proxy...', e);
                        // Fallback to Proxy
                        const proxyUrl = `/api/proxy-image?url=${encodeURIComponent(url)}`;
                        const resp = await fetch(proxyUrl);
                        if (!resp.ok) throw new Error(`Proxy fetch failed: ${resp.status}`);
                        blob = await resp.blob();
                    }

                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onloadend = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(blob);
                    });
                } catch (err) {
                    console.error('All fetch methods failed for:', url, err);
                    return null;
                }
            }

            // --- Image Optimization Utility ---
            function resizeImage(base64Str, maxWidth) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => {
                        let w = img.width;
                        let h = img.height;

                        if (w <= maxWidth) {
                            resolve(base64Str); // No resize needed
                            return;
                        }

                        // Calculate new dimensions
                        const ratio = maxWidth / w;
                        w = maxWidth;
                        h = h * ratio;

                        const canvas = document.createElement('canvas');
                        canvas.width = w;
                        canvas.height = h;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, w, h);

                        // Comress to JPEG 0.8 to save space
                        resolve(canvas.toDataURL('image/jpeg', 0.8));
                    };
                    img.onerror = reject;
                    img.src = base64Str;
                });
            }

            // --- Individual Image Controls ---
            window.copySingleImage = async (btn) => {
                const wrapper = btn.closest('.img-wrapper');
                const img = wrapper.querySelector('img');

                try {
                    const response = await fetch(img.src);
                    const blob = await response.blob();
                    await navigator.clipboard.write([
                        new ClipboardItem({ [blob.type]: blob })
                    ]);
                    alert('å›¾ç‰‡å·²å¤åˆ¶');
                } catch (e) {
                    console.error(e);
                    alert('å¤åˆ¶å¤±è´¥');
                }
            };

            window.downloadSingleImage = (btn) => {
                const wrapper = btn.closest('.img-wrapper');
                const img = wrapper.querySelector('img');
                const link = document.createElement('a');
                link.download = `image_${Date.now()}.jpg`;
                link.href = img.src;
                link.click();
            };

            // --- Bulk Download ---
            window.downloadAllImages = async () => {
                const zip = new JSZip();
                const imgs = document.querySelectorAll('#preview-content img');
                if (imgs.length === 0) return alert('æ²¡æœ‰å‘ç°å›¾ç‰‡');

                const folder = zip.folder("images");
                let count = 0;

                for (let i = 0; i < imgs.length; i++) {
                    const src = imgs[i].src;
                    if (!src.startsWith('data:image')) continue;

                    // Extract base64 data
                    const data = src.split(',')[1];
                    const type = src.substring(src.indexOf(':') + 1, src.indexOf(';'));
                    const ext = type.split('/')[1] || 'jpg';

                    folder.file(`image_${i + 1}.${ext}`, data, { base64: true });
                    count++;
                }

                if (count === 0) return alert('æ²¡æœ‰å¯ä¾›ä¸‹è½½çš„å›¾ç‰‡');

                const content = await zip.generateAsync({ type: "blob" });
                const url = URL.createObjectURL(content);
                const a = document.createElement('a');
                a.href = url;
                a.download = `word_images_${Date.now()}.zip`;
                a.click();
            };

            function handleError(err) {
                console.error(err);
                document.getElementById('preview-content').innerHTML = `
                <div style="text-align:center; color: #D32F2F;">
                    <h3>è½¬æ¢å¤±è´¥</h3>
                    <p>${err.message}</p>
                </div>
            `;
            }

            function copyHTML() {
                const content = document.getElementById('preview-content').innerHTML;
                navigator.clipboard.writeText(content).then(() => {
                    alert('HTML ä»£ç å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
                }).catch(err => {
                    console.error('Failed to copy: ', err);
                    alert('å¤åˆ¶å¤±è´¥ï¼Œè¯·é‡è¯•');
                });
            }

            async function copyRichText() {
                // Clone content to strip controls before copying
                const contentOriginal = document.getElementById('preview-content');
                const contentClone = contentOriginal.cloneNode(true);

                // Remove all .img-controls and unwrap .img-wrapper
                // Remove all .img-controls
                contentClone.querySelectorAll('.img-controls').forEach(el => el.remove());

                // Unwrap .img-wrapper to restore clean <img> tags
                contentClone.querySelectorAll('.img-wrapper').forEach(wrapper => {
                    // Move all children (usually just the img) before the wrapper
                    while (wrapper.firstChild) {
                        wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
                    }
                    // Remove the empty wrapper
                    wrapper.remove();
                });

                const content = contentClone;

                // Note: Images are already handled (local base64 OR cloud url)
                // If user clicked "Convert to Cloud", images are already URLs.
                // If not, they are Base64.
                // No auto-upload logic here anymore, explicit action only.

                try {
                    // æ–¹æ¡ˆ1: ä½¿ç”¨ copy äº‹ä»¶ç›‘å¬å™¨ - æœ€å¯é çš„æ–¹æ³•
                    const copyHandler = (e) => {
                        e.preventDefault();
                        e.clipboardData.setData('text/html', content.innerHTML);
                        e.clipboardData.setData('text/plain', content.innerText);
                        document.removeEventListener('copy', copyHandler);
                    };

                    document.addEventListener('copy', copyHandler);

                    // é€‰ä¸­å†…å®¹å¹¶è§¦å‘å¤åˆ¶
                    const range = document.createRange();
                    range.selectNodeContents(content);
                    const selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(range);

                    const success = document.execCommand('copy');
                    selection.removeAllRanges();

                    if (success) {
                        alert('å›¾æ–‡å†…å®¹å·²å¤åˆ¶ï¼ç°åœ¨å¯ä»¥ç²˜è´´åˆ°å¾®ä¿¡å…¬ä¼—å·ã€Word ç­‰ç¼–è¾‘å™¨ä¸­ã€‚');
                        return;
                    }
                } catch (err) {
                    console.warn('Copy event method failed:', err);
                }

                // æ–¹æ¡ˆ2: ä½¿ç”¨ç°ä»£ Clipboard API
                try {
                    if (navigator.clipboard && navigator.clipboard.write) {
                        const htmlBlob = new Blob([content.innerHTML], { type: 'text/html' });
                        const textBlob = new Blob([content.innerText], { type: 'text/plain' });

                        const clipboardItem = new ClipboardItem({
                            'text/html': htmlBlob,
                            'text/plain': textBlob
                        });

                        await navigator.clipboard.write([clipboardItem]);
                        alert('å›¾æ–‡å†…å®¹å·²å¤åˆ¶ï¼ç°åœ¨å¯ä»¥ç²˜è´´åˆ°ç¼–è¾‘å™¨ä¸­ã€‚');
                        return;
                    }
                } catch (err) {
                    console.warn('Clipboard API failed:', err);
                }

                // æ–¹æ¡ˆ3: æœ€åçš„å…œåº•æ–¹æ¡ˆ
                try {
                    const range = document.createRange();
                    range.selectNodeContents(content);
                    window.getSelection().removeAllRanges();
                    window.getSelection().addRange(range);

                    document.execCommand('copy');
                    window.getSelection().removeAllRanges();
                    alert('å†…å®¹å·²å¤åˆ¶ï¼å¦‚æœå›¾ç‰‡æœªæ˜¾ç¤ºï¼Œè¯·å°è¯•åœ¨æµè§ˆå™¨ä¸­æ‰‹åŠ¨é€‰ä¸­å†…å®¹åæŒ‰ Ctrl+C (æˆ– Cmd+C) å¤åˆ¶ã€‚');
                } catch (err) {
                    console.error('All copy methods failed:', err);
                    alert('è‡ªåŠ¨å¤åˆ¶å¤±è´¥ã€‚è¯·æ‰‹åŠ¨é€‰ä¸­å†…å®¹åæŒ‰ Ctrl+C (æˆ– Cmd+C) å¤åˆ¶ã€‚');
                }
            }

            // --- Auth Logic (Copied from other tools) ---
            async function loadAuthCodes() {
                try {
                    const response = await fetch('auth-codes.json');
                    const data = await response.json();
                    AUTH_CODES = data.tools[TOOL_KEY]?.codes || {};
                } catch (error) {
                    console.warn('Failed to load auth-codes.json, using fallback');
                    // Fallback for local testing without server
                    AUTH_CODES = { "WORD-2025-LOCAL": "Local Dev" };
                }
            }

            function checkAuth() {
                const storedCode = localStorage.getItem(`auth_code_${TOOL_KEY}`);
                if (storedCode && validateCode(storedCode)) {
                    showContent();
                } else {
                    document.getElementById('auth-overlay').style.display = 'flex';
                }
            }

            function validateCode(code) {
                return AUTH_CODES.hasOwnProperty(code);
            }

            function verifyAuth() {
                const input = document.getElementById('auth-code-input');
                const code = input.value.trim();
                const errorMsg = document.getElementById('auth-error');

                if (validateCode(code)) {
                    localStorage.setItem(`auth_code_${TOOL_KEY}`, code);
                    showContent();
                } else {
                    errorMsg.style.display = 'flex';
                    input.classList.add('error');
                }
            }

            function showContent() {
                document.getElementById('auth-overlay').style.display = 'none';
                document.getElementById('main-content').style.display = 'block';
            }

            // Helper to fetch external images and convert to base64
            async function fetchExternalImage(url) {
                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const blob = await response.blob();
                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onloadend = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(blob);
                    });
                } catch (error) {
                    console.error('Error fetching external image:', url, error);
                    return null;
                }
            }

            // --- Cloud Bridge Actions ---
            let uploadedImages = []; // Track explicitly uploaded images for deletion

            async function uploadAllToCloud() {
                const content = document.getElementById('preview-content');
                // Select ALL images that are not already on our cloud
                const imagesToUpload = Array.from(content.querySelectorAll('img'))
                    .filter(img => !img.src.includes('i.111666.best'));

                if (imagesToUpload.length === 0) {
                    return alert('æ²¡æœ‰æ£€æµ‹åˆ°éœ€è¦ä¸Šä¼ çš„æœ¬åœ°å›¾ç‰‡ï¼ˆæˆ–è€…å›¾ç‰‡å·²ç»ä¸Šä¼ è¿‡äº†ï¼‰ã€‚');
                }

                const btn = document.getElementById('btn-cloud-upload');
                const originalText = btn.innerHTML;
                btn.disabled = true;

                try {
                    for (let i = 0; i < imagesToUpload.length; i++) {
                        const img = imagesToUpload[i];
                        btn.innerText = `æ­£åœ¨ä¸Šä¼  ${i + 1}/${imagesToUpload.length}...`;

                        let base64Data = img.src;

                        // If it's a stubborn external URL (not base64), we must fetch it first
                        if (!base64Data.startsWith('data:image')) {
                            console.log('Attempting to fix external URL:', base64Data);
                            try {
                                // Robust Cleaning Logic
                                let cleanSrc = base64Data;

                                // 1. If it contains "http" multiple times (nested urls), take the last one or the one that looks real?
                                // The user example: https://substackcdn.../https://substack-post-media...
                                // Mammoth sometimes concats attributes.
                                // Let's try to extract the first valid http(s) url until a space or quote.

                                // Decode first to handle %22 and %20
                                try { cleanSrc = decodeURIComponent(cleanSrc); } catch (e) { }

                                // Match standard URL pattern (http/https followed by non-whitespace/non-quote)
                                const urlMatch = cleanSrc.match(/(https?:\/\/[^\s"']+)/);
                                if (urlMatch) {
                                    cleanSrc = urlMatch[0];
                                } else {
                                    // Fallback cleanup
                                    cleanSrc = cleanSrc.replace(/["']/g, '').split(/\s/)[0];
                                }

                                console.log('Cleaned URL:', cleanSrc);

                                const fetched = await fetchExternalImage(cleanSrc);
                                if (fetched) {
                                    base64Data = fetched;
                                } else {
                                    // Try proxy if direct failed (fetchExternalImage might fail on CORS)
                                    // Actually fetchExternalImage already tries proxy.
                                    console.warn('Could not fetch/convert external image:', cleanSrc);

                                    // RECOVERY STRATEGY:
                                    // 1. Try to extract inner URL (e.g. valid S3 link inside Substack CDN)
                                    // https://substackcdn.com/.../https://s3... 
                                    const innerMatch = cleanSrc.match(/(https?:\/\/[a-zA-Z0-9.-]+\.s3\.amazonaws\.com\/[^"'\s]+)/);
                                    if (innerMatch && innerMatch[1] !== cleanSrc) {
                                        console.log('Trying inner URL:', innerMatch[1]);
                                        const fetchedInner = await fetchExternalImage(innerMatch[1]);
                                        if (fetchedInner) {
                                            base64Data = fetchedInner;
                                            // success! continue to upload
                                        } else {
                                            // If simple fetch fails, just use the cleaned URL as the source
                                            // At least it fixes the Broken Image icon in the browser
                                            img.src = cleanSrc;
                                            console.log('Fallback: Updated src to cleaned URL (upload skipped)');
                                            continue;
                                        }
                                    } else {
                                        // No inner url, just use clean url
                                        img.src = cleanSrc;
                                        console.log('Fallback: Updated src to cleaned URL (upload skipped)');
                                        continue;
                                    }
                                }
                            } catch (err) {
                                console.error('Error fixing image:', err);
                                continue;
                            }
                        }

                        const cloudUrl = await uploadImageToCloud(base64Data);
                        console.log(`Image ${i} uploaded:`, cloudUrl);

                        if (cloudUrl && cloudUrl.startsWith('http')) {
                            img.src = cloudUrl;
                            img.setAttribute('data-cloud-uploaded', 'true');
                            uploadedImages.push(cloudUrl);
                        } else {
                            console.error('Invalid Cloud URL received:', cloudUrl);
                        }
                    }

                    // Show Success State
                    btn.innerHTML = `<svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor" style="margin-right: 4px;"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg> å·²è½¬ä¸ºäº‘ç«¯å›¾`;
                    btn.onclick = null; // Disable button effectively
                    btn.style.background = '#4CAF50';

                    // Show Delete Button
                    const delBtn = document.getElementById('btn-cloud-delete');
                    delBtn.style.display = 'flex';
                    delBtn.style.display = 'inline-flex'; // Fix display

                    alert('æ‰€æœ‰å›¾ç‰‡å·²æˆåŠŸè½¬ä¸ºäº‘é“¾æ¥ï¼\n\nç°åœ¨æ‚¨å¯ä»¥ï¼š\n1. éšæ„é€‰ä¸­ä»»æ„æ–‡å­—å’Œå›¾ç‰‡è¿›è¡Œå¤åˆ¶ã€‚\n2. ç²˜è´´åˆ°çŸ¥ä¹ç­‰å¹³å°ã€‚\n3. å¦‚æœä¸éœ€è¦äº†ï¼Œç‚¹å‡»çº¢è‰²æŒ‰é’®åˆ é™¤äº‘ç«¯å›¾ç‰‡ã€‚');

                } catch (e) {
                    console.error(e);
                    alert('ä¸Šä¼ è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯ï¼Œè¯·æŸ¥çœ‹æ§åˆ¶å°ã€‚');
                    btn.innerHTML = originalText;
                    btn.disabled = false;
                }
            }

            async function deleteAllCloudImages() {
                if (uploadedImages.length === 0) return alert('æ²¡æœ‰è®°å½•åˆ°æœ¬æ¬¡ä¸Šä¼ çš„å›¾ç‰‡ã€‚');
                if (!confirm(`ç¡®å®šè¦åˆ é™¤ ${uploadedImages.length} å¼ äº‘ç«¯å›¾ç‰‡å—ï¼Ÿ\nåˆ é™¤åï¼Œå¤–éƒ¨é“¾æ¥å°†å¤±æ•ˆã€‚`)) return;

                const btn = document.getElementById('btn-cloud-delete');
                const originalText = btn.innerHTML;
                btn.disabled = true;
                btn.innerText = 'æ­£åœ¨åˆ é™¤...';

                let failCount = 0;
                for (const url of uploadedImages) {
                    try {
                        const res = await fetch('/api/upload-image', {
                            method: 'DELETE',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ url })
                        });
                        if (!res.ok) failCount++;
                    } catch (e) {
                        console.error('Delete failed for', url, e);
                        failCount++;
                    }
                }

                if (failCount > 0) {
                    alert(`åˆ é™¤æ“ä½œå®Œæˆï¼Œä½†æœ‰ ${failCount} å¼ å›¾ç‰‡åˆ é™¤å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°ã€‚`);
                } else {
                    alert('æ‰€æœ‰å›¾ç‰‡å·²ä»äº‘ç«¯åˆ é™¤ã€‚');
                    // Reset UI
                    location.reload(); // Simple reset
                }
            }

            // Helper to convert Base64 to Blob
            function b64toBlob(b64Data, contentType = '', sliceSize = 512) {
                const byteCharacters = atob(b64Data);
                const byteArrays = [];

                for (let offset = 0; offset < byteCharacters.length; offset += sliceSize) {
                    const slice = byteCharacters.slice(offset, offset + sliceSize);
                    const byteNumbers = new Array(slice.length);
                    for (let i = 0; i < slice.length; i++) {
                        byteNumbers[i] = slice.charCodeAt(i);
                    }
                    const byteArray = new Uint8Array(byteNumbers);
                    byteArrays.push(byteArray);
                }

                const blob = new Blob(byteArrays, { type: contentType });
                return blob;
            }

            async function uploadImageToCloud(base64Data) {
                try {
                    // Prepare FormData for Direct Upload
                    // Split base64: "data:image/jpeg;base64,....."
                    const parts = base64Data.split(';base64,');
                    const contentType = parts[0].split(':')[1];
                    const rawBase64 = parts[1];

                    const blob = b64toBlob(rawBase64, contentType);
                    const formData = new FormData();
                    formData.append('image', blob, 'upload.jpg');

                    console.log('Attempting Direct Client-Side Upload...');

                    // Try Direct Upload to bypass Cloudflare on Vercel
                    const response = await fetch('https://i.111666.best/image', {
                        method: 'POST',
                        headers: {
                            'Auth-Token': 'dcone2025'
                            // Content-Type is set automatically by fetch with FormData
                        },
                        body: formData
                    });

                    const text = await response.text();
                    console.log('Upload Response:', text);

                    let finalUrl = '';
                    try {
                        // Try parsing JSON
                        const json = JSON.parse(text);
                        finalUrl = json.url || json.data?.url || json.src || json.message;
                    } catch (e) {
                        // If text, check if it's a URL
                        if (text.startsWith('http')) finalUrl = text;
                        else if (text.startsWith('/')) finalUrl = 'https://i.111666.best' + text;
                    }

                    if (finalUrl && finalUrl.startsWith('http')) {
                        return finalUrl;
                    } else {
                        console.warn('Direct upload failed or returned invalid data:', text);
                        // Fallback to Proxy if Direct fails (e.g. CORS block)
                        // But if Direct blocked by Cloudflare, Proxy likely blocked too. 
                        // Let's try Proxy as last resort.
                        return await uploadImageToCloudProxy(base64Data);
                    }

                } catch (e) {
                    console.error('Direct upload network error (CORS?):', e);
                    return await uploadImageToCloudProxy(base64Data);
                }
            }

            async function uploadImageToCloudProxy(base64Data) {
                try {
                    console.log('Falling back to Proxy Upload...');
                    const response = await fetch('/api/upload-image', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ image: base64Data })
                    });

                    const data = await response.json();
                    if (data.url && data.url.startsWith('http')) {
                        return data.url;
                    }
                    console.warn('Proxy upload failed:', data);
                    return null;
                } catch (e) {
                    console.error('Proxy upload error:', e);
                    return null;
                }
            }
        </script>
</body>

</html>